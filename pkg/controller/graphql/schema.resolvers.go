package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"

	goerr "github.com/m-mizutani/goerr/v2"
	"github.com/secmon-lab/beehive/pkg/domain/interfaces"
	"github.com/secmon-lab/beehive/pkg/domain/model"
	graphql1 "github.com/secmon-lab/beehive/pkg/domain/model/graphql"
)

// Noop is the resolver for the noop field.
func (r *mutationResolver) Noop(ctx context.Context) (*bool, error) {
	result := true
	return &result, nil
}

// FetchSource is the resolver for the fetchSource field.
func (r *mutationResolver) FetchSource(ctx context.Context, sourceID string) (*graphql1.History, error) {
	// Execute fetch for the specified source using cached sourcesMap
	history, err := r.fetchUseCase.FetchSourceByID(ctx, r.sourcesMap, sourceID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to fetch source", goerr.V("source_id", sourceID))
	}

	return toGraphQLHistory(history), nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// ListIoCs is the resolver for the listIoCs field.
func (r *queryResolver) ListIoCs(ctx context.Context, options *graphql1.IoCListOptions) (*graphql1.IoCConnection, error) {
	// Convert GraphQL input to domain model
	var opts *model.IoCListOptions
	if options != nil {
		opts = &model.IoCListOptions{
			Offset:    ptrIntValue(options.Offset),
			Limit:     ptrIntValue(options.Limit),
			SortField: toModelSortField(options.SortField),
			SortOrder: toModelSortOrder(options.SortOrder),
		}
	}

	connection, err := r.repo.ListIoCs(ctx, opts)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list IoCs")
	}

	items := make([]*graphql1.IoC, len(connection.Items))
	for i, ioc := range connection.Items {
		items[i] = toGraphQLIoC(ioc)
	}

	return &graphql1.IoCConnection{
		Items: items,
		Total: connection.Total,
	}, nil
}

// GetIoC is the resolver for the getIoC field.
func (r *queryResolver) GetIoC(ctx context.Context, id string) (*graphql1.IoC, error) {
	ioc, err := r.repo.GetIoC(ctx, id)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get IoC", goerr.V("id", id))
	}

	return toGraphQLIoC(ioc), nil
}

// ListSources is the resolver for the listSources field.
func (r *queryResolver) ListSources(ctx context.Context) ([]*graphql1.Source, error) {
	// Get loaders from context
	loaders := LoadersFromContext(ctx)

	// Collect all source IDs and create GraphQL sources
	var result []*graphql1.Source
	type sourceWithThunk struct {
		gqlSrc *graphql1.Source
		thunk  func() (*model.SourceState, error)
	}
	sourceThunks := make([]sourceWithThunk, 0, len(r.sourcesMap))

	// Iterate over cached sourcesMap
	for id, src := range r.sourcesMap {
		var srcType string
		if src.Type == model.SourceTypeRSS {
			srcType = "rss"
		} else {
			srcType = "feed"
		}

		gqlSrc := &graphql1.Source{
			ID:      id,
			Type:    srcType,
			URL:     src.URL,
			Tags:    src.Tags,
			Enabled: src.Enabled,
		}

		// Queue data loader request (doesn't execute yet)
		thunk := loaders.SourceStateLoader.Load(ctx, id)
		sourceThunks = append(sourceThunks, sourceWithThunk{gqlSrc: gqlSrc, thunk: thunk})
	}

	// Execute all thunks (triggers batch loading)
	for _, st := range sourceThunks {
		state, err := st.thunk()
		if err != nil && !errors.Is(err, interfaces.ErrSourceStateNotFound) {
			return nil, goerr.Wrap(err, "failed to get source state", goerr.V("source_id", st.gqlSrc.ID))
		}

		if state != nil {
			st.gqlSrc.State = toGraphQLSourceState(state)
		}

		result = append(result, st.gqlSrc)
	}

	return result, nil
}

// GetSource is the resolver for the getSource field.
func (r *queryResolver) GetSource(ctx context.Context, id string) (*graphql1.Source, error) {
	// Look up source in cached sourcesMap
	src, found := r.sourcesMap[id]
	if !found {
		return nil, goerr.New("source not found", goerr.V("id", id))
	}

	var srcType string
	if src.Type == model.SourceTypeRSS {
		srcType = "rss"
	} else {
		srcType = "feed"
	}

	gqlSrc := &graphql1.Source{
		ID:      id,
		Type:    srcType,
		URL:     src.URL,
		Tags:    src.Tags,
		Enabled: src.Enabled,
	}

	// Get source state from repository
	state, err := r.repo.GetState(ctx, id)
	if err != nil && !errors.Is(err, interfaces.ErrSourceStateNotFound) {
		return nil, goerr.Wrap(err, "failed to get source state", goerr.V("id", id))
	}

	if state != nil {
		gqlSrc.State = toGraphQLSourceState(state)
	}

	return gqlSrc, nil
}

// ListHistories is the resolver for the listHistories field.
func (r *queryResolver) ListHistories(ctx context.Context, sourceID string, limit *int, offset *int) (*graphql1.HistoryConnection, error) {
	actualLimit := 0
	if limit != nil {
		actualLimit = *limit
	}

	actualOffset := 0
	if offset != nil {
		actualOffset = *offset
	}

	histories, _, err := r.repo.ListHistoriesBySource(ctx, sourceID, actualLimit, actualOffset)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list histories",
			goerr.V("source_id", sourceID),
			goerr.V("limit", actualLimit),
			goerr.V("offset", actualOffset))
	}

	items := make([]*graphql1.History, len(histories))
	for i, h := range histories {
		items[i] = toGraphQLHistory(h)
	}

	return &graphql1.HistoryConnection{
		Items: items,
		Total: nil, // Not computed for performance reasons
	}, nil
}

// GetHistory is the resolver for the getHistory field.
func (r *queryResolver) GetHistory(ctx context.Context, sourceID string, id string) (*graphql1.History, error) {
	history, err := r.repo.GetHistory(ctx, sourceID, id)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get history",
			goerr.V("source_id", sourceID),
			goerr.V("history_id", id))
	}

	return toGraphQLHistory(history), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
