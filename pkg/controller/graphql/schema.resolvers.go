package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"

	goerr "github.com/m-mizutani/goerr/v2"
	"github.com/secmon-lab/beehive/pkg/cli/config"
	"github.com/secmon-lab/beehive/pkg/domain/interfaces"
	"github.com/secmon-lab/beehive/pkg/domain/model"
	graphql1 "github.com/secmon-lab/beehive/pkg/domain/model/graphql"
)

// Noop is the resolver for the noop field.
func (r *mutationResolver) Noop(ctx context.Context) (*bool, error) {
	result := true
	return &result, nil
}

// FetchSource is the resolver for the fetchSource field.
func (r *mutationResolver) FetchSource(ctx context.Context, sourceID string) (*graphql1.History, error) {
	// Load sources configuration
	cfg, err := config.LoadConfig(r.sourcesConfigPath)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to load sources config")
	}

	// Convert config to model.Source map
	sourcesMap := make(map[string]model.Source)

	// Add RSS sources
	for id, src := range cfg.RSS {
		sourcesMap[id] = model.Source{
			Type:    model.SourceTypeRSS,
			URL:     src.URL,
			Tags:    ensureStringSlice(src.Tags.Strings()),
			Enabled: !src.Disabled,
			RSSConfig: &model.RSSConfig{
				MaxArticles: src.MaxArticles,
			},
		}
	}

	// Add Feed sources
	for id, src := range cfg.Feed {
		sourcesMap[id] = model.Source{
			Type:    model.SourceTypeFeed,
			URL:     src.GetURL(),
			Tags:    ensureStringSlice(src.Tags.Strings()),
			Enabled: !src.Disabled,
			FeedConfig: &model.FeedConfig{
				Schema:   string(src.Schema),
				MaxItems: src.MaxItems,
			},
		}
	}

	// Execute fetch for the specified source
	history, err := r.fetchUseCase.FetchSourceByID(ctx, sourcesMap, sourceID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to fetch source", goerr.V("source_id", sourceID))
	}

	return toGraphQLHistory(history), nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// ListIoCs is the resolver for the listIoCs field.
func (r *queryResolver) ListIoCs(ctx context.Context, options *graphql1.IoCListOptions) (*graphql1.IoCConnection, error) {
	// Convert GraphQL input to domain model
	var opts *model.IoCListOptions
	if options != nil {
		opts = &model.IoCListOptions{
			Offset:    ptrIntValue(options.Offset),
			Limit:     ptrIntValue(options.Limit),
			SortField: toModelSortField(options.SortField),
			SortOrder: toModelSortOrder(options.SortOrder),
		}
	}

	connection, err := r.repo.ListIoCs(ctx, opts)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list IoCs")
	}

	items := make([]*graphql1.IoC, len(connection.Items))
	for i, ioc := range connection.Items {
		items[i] = toGraphQLIoC(ioc)
	}

	return &graphql1.IoCConnection{
		Items: items,
		Total: connection.Total,
	}, nil
}

// GetIoC is the resolver for the getIoC field.
func (r *queryResolver) GetIoC(ctx context.Context, id string) (*graphql1.IoC, error) {
	ioc, err := r.repo.GetIoC(ctx, id)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get IoC", goerr.V("id", id))
	}

	return toGraphQLIoC(ioc), nil
}

// ListSources is the resolver for the listSources field.
func (r *queryResolver) ListSources(ctx context.Context) ([]*graphql1.Source, error) {
	// Load sources configuration using LoadConfig
	cfg, err := config.LoadConfig(r.sourcesConfigPath)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to load sources config")
	}

	// Get loaders from context
	loaders := LoadersFromContext(ctx)

	// Collect all source IDs and create GraphQL sources
	var result []*graphql1.Source
	type sourceWithThunk struct {
		gqlSrc *graphql1.Source
		thunk  func() (*model.SourceState, error)
	}
	sourceThunks := make([]sourceWithThunk, 0, len(cfg.RSS)+len(cfg.Feed))

	// Add RSS sources
	for id, src := range cfg.RSS {
		gqlSrc := &graphql1.Source{
			ID:      id,
			Type:    "rss",
			URL:     src.URL,
			Tags:    ensureStringSlice(src.Tags.Strings()),
			Enabled: !src.Disabled,
		}

		// Queue data loader request (doesn't execute yet)
		thunk := loaders.SourceStateLoader.Load(ctx, id)
		sourceThunks = append(sourceThunks, sourceWithThunk{gqlSrc: gqlSrc, thunk: thunk})
	}

	// Add Feed sources
	for id, src := range cfg.Feed {
		gqlSrc := &graphql1.Source{
			ID:      id,
			Type:    "feed",
			URL:     src.GetURL(),
			Tags:    ensureStringSlice(src.Tags.Strings()),
			Enabled: !src.Disabled,
		}

		// Queue data loader request (doesn't execute yet)
		thunk := loaders.SourceStateLoader.Load(ctx, id)
		sourceThunks = append(sourceThunks, sourceWithThunk{gqlSrc: gqlSrc, thunk: thunk})
	}

	// Execute all thunks (triggers batch loading)
	for _, st := range sourceThunks {
		state, err := st.thunk()
		if err != nil && !errors.Is(err, interfaces.ErrSourceStateNotFound) {
			return nil, goerr.Wrap(err, "failed to get source state", goerr.V("source_id", st.gqlSrc.ID))
		}

		if state != nil {
			st.gqlSrc.State = toGraphQLSourceState(state)
		}

		result = append(result, st.gqlSrc)
	}

	return result, nil
}

// GetSource is the resolver for the getSource field.
func (r *queryResolver) GetSource(ctx context.Context, id string) (*graphql1.Source, error) {
	// Load sources configuration
	cfg, err := config.LoadConfig(r.sourcesConfigPath)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to load sources config")
	}

	var gqlSrc *graphql1.Source

	// Check in RSS sources
	if rssSrc, found := cfg.RSS[id]; found {
		gqlSrc = &graphql1.Source{
			ID:      id,
			Type:    "rss",
			URL:     rssSrc.URL,
			Tags:    ensureStringSlice(rssSrc.Tags.Strings()),
			Enabled: !rssSrc.Disabled,
		}
	} else if feedSrc, found := cfg.Feed[id]; found {
		// Check in Feed sources
		gqlSrc = &graphql1.Source{
			ID:      id,
			Type:    "feed",
			URL:     feedSrc.GetURL(),
			Tags:    ensureStringSlice(feedSrc.Tags.Strings()),
			Enabled: !feedSrc.Disabled,
		}
	} else {
		return nil, goerr.New("source not found", goerr.V("id", id))
	}

	// Get source state from repository
	state, err := r.repo.GetState(ctx, id)
	if err != nil && !errors.Is(err, interfaces.ErrSourceStateNotFound) {
		return nil, goerr.Wrap(err, "failed to get source state", goerr.V("id", id))
	}

	if state != nil {
		gqlSrc.State = toGraphQLSourceState(state)
	}

	return gqlSrc, nil
}

// ListHistories is the resolver for the listHistories field.
func (r *queryResolver) ListHistories(ctx context.Context, sourceID string, limit *int, offset *int) (*graphql1.HistoryConnection, error) {
	actualLimit := 0
	if limit != nil {
		actualLimit = *limit
	}

	actualOffset := 0
	if offset != nil {
		actualOffset = *offset
	}

	histories, total, err := r.repo.ListHistoriesBySource(ctx, sourceID, actualLimit, actualOffset)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list histories",
			goerr.V("source_id", sourceID),
			goerr.V("limit", actualLimit),
			goerr.V("offset", actualOffset))
	}

	items := make([]*graphql1.History, len(histories))
	for i, h := range histories {
		items[i] = toGraphQLHistory(h)
	}

	return &graphql1.HistoryConnection{
		Items: items,
		Total: total,
	}, nil
}

// GetHistory is the resolver for the getHistory field.
func (r *queryResolver) GetHistory(ctx context.Context, sourceID string, id string) (*graphql1.History, error) {
	history, err := r.repo.GetHistory(ctx, sourceID, id)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get history",
			goerr.V("source_id", sourceID),
			goerr.V("history_id", id))
	}

	return toGraphQLHistory(history), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
