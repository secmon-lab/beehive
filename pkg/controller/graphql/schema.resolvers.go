package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"
	"time"

	"github.com/m-mizutani/goerr/v2"
	"github.com/secmon-lab/beehive/pkg/cli/config"
	"github.com/secmon-lab/beehive/pkg/domain/interfaces"
	"github.com/secmon-lab/beehive/pkg/domain/model"
	graphql1 "github.com/secmon-lab/beehive/pkg/domain/model/graphql"
)

// Noop is the resolver for the noop field.
func (r *mutationResolver) Noop(ctx context.Context) (*bool, error) {
	result := true
	return &result, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// ListIoCs is the resolver for the listIoCs field.
func (r *queryResolver) ListIoCs(ctx context.Context, options *graphql1.IoCListOptions) (*graphql1.IoCConnection, error) {
	// Convert GraphQL input to domain model
	var opts *model.IoCListOptions
	if options != nil {
		opts = &model.IoCListOptions{
			Offset:    ptrIntValue(options.Offset),
			Limit:     ptrIntValue(options.Limit),
			SortField: toModelSortField(options.SortField),
			SortOrder: toModelSortOrder(options.SortOrder),
		}
	}

	connection, err := r.repo.ListIoCs(ctx, opts)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list IoCs")
	}

	items := make([]*graphql1.IoC, len(connection.Items))
	for i, ioc := range connection.Items {
		items[i] = toGraphQLIoC(ioc)
	}

	return &graphql1.IoCConnection{
		Items: items,
		Total: connection.Total,
	}, nil
}

// GetIoC is the resolver for the getIoC field.
func (r *queryResolver) GetIoC(ctx context.Context, id string) (*graphql1.IoC, error) {
	ioc, err := r.repo.GetIoC(ctx, id)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get IoC", goerr.V("id", id))
	}

	return toGraphQLIoC(ioc), nil
}

// ListSources is the resolver for the listSources field.
func (r *queryResolver) ListSources(ctx context.Context) ([]*graphql1.Source, error) {
	// Load sources configuration
	sources, err := config.LoadSources(r.sourcesConfigPath)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to load sources config")
	}

	// Get loaders from context
	loaders := LoadersFromContext(ctx)

	// Collect all source IDs and create GraphQL sources
	var result []*graphql1.Source
	type sourceWithThunk struct {
		gqlSrc *graphql1.Source
		thunk  func() (*model.SourceState, error)
	}
	sourceThunks := make([]sourceWithThunk, 0, len(sources.Sources))

	for id, src := range sources.Sources {
		gqlSrc := &graphql1.Source{
			ID:      id,
			Type:    string(src.Type),
			URL:     src.URL,
			Tags:    src.Tags,
			Enabled: src.Enabled,
		}

		// Queue data loader request (doesn't execute yet)
		thunk := loaders.SourceStateLoader.Load(ctx, id)
		sourceThunks = append(sourceThunks, sourceWithThunk{gqlSrc: gqlSrc, thunk: thunk})
	}

	// Execute all thunks (triggers batch loading)
	for _, st := range sourceThunks {
		state, err := st.thunk()
		if err != nil && !errors.Is(err, interfaces.ErrSourceStateNotFound) {
			return nil, goerr.Wrap(err, "failed to get source state", goerr.V("source_id", st.gqlSrc.ID))
		}

		if state != nil {
			st.gqlSrc.State = toGraphQLSourceState(state)
		}

		result = append(result, st.gqlSrc)
	}

	return result, nil
}

// ListHistories is the resolver for the listHistories field.
func (r *queryResolver) ListHistories(ctx context.Context, sourceID string, limit *int, offset *int) (*graphql1.HistoryConnection, error) {
	actualLimit := 20
	if limit != nil {
		actualLimit = *limit
	}

	actualOffset := 0
	if offset != nil {
		actualOffset = *offset
	}

	histories, err := r.repo.ListHistoriesBySource(ctx, sourceID, actualLimit, actualOffset)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list histories",
			goerr.V("source_id", sourceID),
			goerr.V("limit", actualLimit),
			goerr.V("offset", actualOffset))
	}

	items := make([]*graphql1.History, len(histories))
	for i, h := range histories {
		items[i] = toGraphQLHistory(h)
	}

	return &graphql1.HistoryConnection{
		Items: items,
		Total: len(histories),
	}, nil
}

// GetHistory is the resolver for the getHistory field.
func (r *queryResolver) GetHistory(ctx context.Context, sourceID string, id string) (*graphql1.History, error) {
	history, err := r.repo.GetHistory(ctx, sourceID, id)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get history",
			goerr.V("source_id", sourceID),
			goerr.V("history_id", id))
	}

	return toGraphQLHistory(history), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// Helper functions

func ptrIntValue(ptr *int) int {
	if ptr == nil {
		return 0
	}
	return *ptr
}

func toModelSortField(field *graphql1.IoCSortField) model.IoCSortField {
	if field == nil {
		return ""
	}
	switch *field {
	case graphql1.IoCSortFieldType:
		return model.IoCSortByType
	case graphql1.IoCSortFieldValue:
		return model.IoCSortByValue
	case graphql1.IoCSortFieldSourceID:
		return model.IoCSortBySourceID
	case graphql1.IoCSortFieldStatus:
		return model.IoCSortByStatus
	case graphql1.IoCSortFieldFirstSeenAt:
		return model.IoCSortByFirstSeenAt
	case graphql1.IoCSortFieldUpdatedAt:
		return model.IoCSortByUpdatedAt
	default:
		return ""
	}
}

func toModelSortOrder(order *graphql1.SortOrder) model.SortOrder {
	if order == nil {
		return ""
	}
	switch *order {
	case graphql1.SortOrderAsc:
		return model.SortOrderAsc
	case graphql1.SortOrderDesc:
		return model.SortOrderDesc
	default:
		return ""
	}
}

func toGraphQLIoC(ioc *model.IoC) *graphql1.IoC {
	var sourceURL *string
	if ioc.SourceURL != "" {
		sourceURL = &ioc.SourceURL
	}

	return &graphql1.IoC{
		ID:          ioc.ID,
		SourceID:    ioc.SourceID,
		SourceType:  ioc.SourceType,
		Type:        string(ioc.Type),
		Value:       ioc.Value,
		Description: ioc.Description,
		SourceURL:   sourceURL,
		Context:     ioc.Context,
		Status:      string(ioc.Status),
		FirstSeenAt: ioc.FirstSeenAt,
		UpdatedAt:   ioc.UpdatedAt,
	}
}

func toGraphQLSourceState(state *model.SourceState) *graphql1.SourceState {
	var lastFetchedAt *time.Time
	var lastItemID *string
	var lastItemDate *time.Time
	var lastError *string

	if !state.LastFetchedAt.IsZero() {
		lastFetchedAt = &state.LastFetchedAt
	}
	if state.LastItemID != "" {
		lastItemID = &state.LastItemID
	}
	if !state.LastItemDate.IsZero() {
		lastItemDate = &state.LastItemDate
	}
	if state.LastError != "" {
		lastError = &state.LastError
	}

	return &graphql1.SourceState{
		SourceID:      state.SourceID,
		LastFetchedAt: lastFetchedAt,
		LastItemID:    lastItemID,
		LastItemDate:  lastItemDate,
		ItemCount:     int(state.ItemCount),
		ErrorCount:    int(state.ErrorCount),
		LastError:     lastError,
		UpdatedAt:     state.UpdatedAt,
	}
}

func toGraphQLHistory(h *model.History) *graphql1.History {
	errors := make([]*graphql1.FetchError, len(h.Errors))
	for i, e := range h.Errors {
		values := make([]*graphql1.KeyValue, 0, len(e.Values))
		for k, v := range e.Values {
			values = append(values, &graphql1.KeyValue{
				Key:   k,
				Value: v,
			})
		}

		errors[i] = &graphql1.FetchError{
			Message: e.Message,
			Values:  values,
		}
	}

	return &graphql1.History{
		ID:             h.ID,
		SourceID:       h.SourceID,
		SourceType:     string(h.SourceType),
		Status:         string(h.Status),
		StartedAt:      h.StartedAt,
		CompletedAt:    h.CompletedAt,
		ProcessingTime: int(h.ProcessingTime / time.Millisecond),
		ItemsFetched:   h.ItemsFetched,
		IoCsExtracted:  h.IoCsExtracted,
		IoCsCreated:    h.IoCsCreated,
		IoCsUpdated:    h.IoCsUpdated,
		IoCsUnchanged:  h.IoCsUnchanged,
		ErrorCount:     h.ErrorCount,
		Errors:         errors,
		CreatedAt:      h.CreatedAt,
	}
}
